
This tutorial introduces the core concepts of pylinkage and walks you through
building and simulating your first linkage mechanism.


Core Concepts
-------------

Pylinkage models planar linkage mechanisms using three main components:

1. **Joints**: Points that connect linkage members (bars). Different joint types
   define different motion constraints.
2. **Linkage**: A collection of joints that form a complete mechanism.
3. **Simulation**: The process of computing joint positions as the mechanism moves.

Joint Types
^^^^^^^^^^^

Pylinkage provides several joint types:

- **Static**: A fixed point in space (used as an anchor/frame)
- **Crank**: A rotating motor joint that drives the mechanism
- **Revolute**: A pin joint connecting two parent joints with distance constraints
- **Fixed**: A joint with fixed distance constraints to two parents
- **Linear**: A joint constrained to move along a line

Your First Linkage: Four-Bar Mechanism
--------------------------------------

A four-bar linkage is the simplest closed-loop mechanism. Let's build one step by step.

Step 1: Import pylinkage
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

   import pylinkage as pl

Step 2: Define the Joints
^^^^^^^^^^^^^^^^^^^^^^^^^

We need a crank (motor) and a revolute joint to close the loop:

.. code-block:: python

   # Create the crank (motor) joint
   # - Fixed at origin (0, 0)
   # - Rotates with radius 1
   crank = pl.Crank(
       x=0, y=1,                    # Initial position
       joint0=(0, 0),               # Anchor point (fixed in space)
       angle=0.31,                  # Initial angle (radians)
       distance=1,                  # Crank arm length
       name="Crank"
   )

   # Create the revolute joint (closes the loop)
   # - Connects to the crank and a fixed point
   # - Constrained by two distances
   pin = pl.Revolute(
       x=3, y=2,                    # Initial position
       joint0=crank,                # First parent: the crank
       joint1=(3, 0),               # Second parent: fixed point
       distance0=3,                 # Distance from crank
       distance1=1,                 # Distance from fixed point
       name="Output"
   )

Step 3: Create the Linkage
^^^^^^^^^^^^^^^^^^^^^^^^^^

Wrap the joints in a ``Linkage`` object:

.. code-block:: python

   linkage = pl.Linkage(
       joints=(crank, pin),         # All joints in the mechanism
       order=(crank, pin),          # Order to solve (crank first, then pin)
       name="Four-bar linkage"
   )

Step 4: Simulate the Motion
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Run a simulation to see the mechanism move through a complete cycle:

.. code-block:: python

   # Simulate one complete revolution
   # Returns positions of all joints at each step
   loci = tuple(linkage.step())

   # Each element in loci is a tuple of joint positions
   # loci[0] = ((crank_x, crank_y), (pin_x, pin_y)) at step 0
   print(f"Simulation steps: {len(loci)}")
   print(f"Final crank position: {loci[-1][0]}")
   print(f"Final output position: {loci[-1][1]}")

Step 5: Visualize the Linkage
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Use the built-in visualizer to see the mechanism in action:

.. code-block:: python

   # Show an animated visualization
   pl.show_linkage(linkage)

This opens a matplotlib window showing the linkage animating through its motion cycle.

Complete Example
----------------

Here's the complete code:

.. code-block:: python

   import pylinkage as pl

   # Define joints
   crank = pl.Crank(
       x=0, y=1,
       joint0=(0, 0),
       angle=0.31,
       distance=1,
       name="Crank"
   )

   pin = pl.Revolute(
       x=3, y=2,
       joint0=crank,
       joint1=(3, 0),
       distance0=3,
       distance1=1,
       name="Output"
   )

   # Create linkage
   linkage = pl.Linkage(
       joints=(crank, pin),
       order=(crank, pin),
       name="Four-bar linkage"
   )

   # Visualize
   pl.show_linkage(linkage)

Understanding the Constraint System
-----------------------------------

Each joint has constraints that define its relationship to parent joints.
You can get and set these constraints programmatically:

.. code-block:: python

   # Get all constraints as a flat list
   constraints = list(linkage.get_num_constraints())
   print(f"Constraints: {constraints}")
   # Output: [0.31, 1, 3, 1]
   # (crank angle, crank distance, revolute distance0, revolute distance1)

   # Modify constraints
   constraints[0] = 0.5  # Change crank angle
   linkage.set_num_constraints(constraints)

   # Get joint positions
   coords = linkage.get_coords()
   print(f"Joint positions: {coords}")

Handling Errors
---------------

Some configurations are geometrically impossible. Pylinkage raises
``UnbuildableError`` when a linkage cannot be assembled:

.. code-block:: python

   try:
       # Try to step with invalid constraints
       invalid_linkage.step()
   except pl.UnbuildableError:
       print("Linkage cannot be built with these constraints")

Custom Joint Creation
=====================

This tutorial shows how to create custom joint types by extending the base
``Joint`` class. Custom joints let you model specialized mechanical constraints
not covered by the built-in joint types.

Understanding the Joint Interface
---------------------------------

All joints in pylinkage inherit from the abstract ``Joint`` class and must
implement three methods:

1. ``get_constraints()``: Returns the geometric constraints (distances, angles)
2. ``set_constraints()``: Sets the geometric constraints
3. ``reload(dt)``: Computes the joint's position based on its parents and constraints

The base ``Joint`` class provides:

- ``x``, ``y``: Current position coordinates
- ``joint0``, ``joint1``: Parent joints (can be ``None``)
- ``name``: Human-readable identifier
- ``coord()``: Returns ``(x, y)`` tuple
- ``set_coord(x, y)``: Sets position

Example: Slider Joint
---------------------

Let's create a slider joint that moves along a line defined by two parent points.
Unlike ``Linear`` which constrains to an infinite line, our slider will be
constrained to move only between its parent points.

Step 1: Define the Class
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

   from pylinkage.joints.joint import Joint


   class Slider(Joint):
       """A joint that slides between two parent points.

       The joint's position is determined by a parameter ``t`` where:
       - t=0 means the joint is at joint0's position
       - t=1 means the joint is at joint1's position
       - Values between 0 and 1 interpolate linearly
       """

       __slots__ = ("t",)

       def __init__(
           self,
           x=0,
           y=0,
           joint0=None,
           joint1=None,
           t=0.5,
           name=None,
       ):
           """Create a Slider joint.

           :param x: Initial x position.
           :param y: Initial y position.
           :param joint0: First parent joint (start of slide).
           :param joint1: Second parent joint (end of slide).
           :param t: Position parameter (0 to 1).
           :param name: Joint name.
           """
           super().__init__(x, y, joint0, joint1, name)
           self.t = t

Step 2: Implement get_constraints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Return the geometric parameters that define this joint's motion:

.. code-block:: python

       def get_constraints(self):
           """Return the slide parameter as constraint."""
           return (self.t,)

Step 3: Implement set_constraints
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Accept new constraint values:

.. code-block:: python

       def set_constraints(self, t=None):
           """Set the slide parameter.

           :param t: New position parameter (0 to 1).
           """
           if t is not None:
               self.t = t

Step 4: Implement reload
^^^^^^^^^^^^^^^^^^^^^^^^

Compute the joint's position based on parent positions and constraints:

.. code-block:: python

       def reload(self, dt=1):
           """Recompute position by interpolating between parents.

           :param dt: Time step (unused for this joint type).
           """
           if self.joint0 is None or self.joint1 is None:
               return

           # Get parent positions
           x0, y0 = self.joint0.coord()
           x1, y1 = self.joint1.coord()

           # Linear interpolation
           self.x = x0 + self.t * (x1 - x0)
           self.y = y0 + self.t * (y1 - y0)

Complete Slider Implementation
------------------------------

Here's the complete custom joint:

.. code-block:: python

   from pylinkage.joints.joint import Joint


   class Slider(Joint):
       """A joint that slides between two parent points."""

       __slots__ = ("t",)

       def __init__(
           self,
           x=0,
           y=0,
           joint0=None,
           joint1=None,
           t=0.5,
           name=None,
       ):
           super().__init__(x, y, joint0, joint1, name)
           self.t = t

       def get_constraints(self):
           return (self.t,)

       def set_constraints(self, t=None):
           if t is not None:
               self.t = t

       def reload(self, dt=1):
           if self.joint0 is None or self.joint1 is None:
               return
           x0, y0 = self.joint0.coord()
           x1, y1 = self.joint1.coord()
           self.x = x0 + self.t * (x1 - x0)
           self.y = y0 + self.t * (y1 - y0)

Using the Custom Joint
----------------------

Here's how to use the slider in a linkage:

.. code-block:: python

   import pylinkage as pl

   # Define anchor points
   p1 = pl.Static(0, 0, name="P1")
   p2 = pl.Static(4, 0, name="P2")

   # Create slider between points
   slider = Slider(
       joint0=p1,
       joint1=p2,
       t=0.5,        # Start in the middle
       name="Slider"
   )

   # Create a crank to drive motion
   crank = pl.Crank(
       joint0=(2, 2),
       angle=0,
       distance=1,
       name="Crank"
   )

   # Connect crank to slider with a revolute joint
   connector = pl.Revolute(
       joint0=crank,
       joint1=slider,
       distance0=2,
       distance1=0.5,
       name="Connector"
   )

   # Note: For this to work, slider.t would need to be updated
   # based on the mechanism's geometry, which requires more
   # sophisticated constraint solving.

Example: Oscillating Joint
--------------------------

Here's another example: a joint that oscillates sinusoidally over time.

.. code-block:: python

   import math
   from pylinkage.joints.joint import Joint


   class Oscillator(Joint):
       """A joint that moves sinusoidally around a center point."""

       __slots__ = ("amplitude", "frequency", "phase", "_time")

       def __init__(
           self,
           x=0,
           y=0,
           joint0=None,
           amplitude=1.0,
           frequency=1.0,
           phase=0.0,
           name=None,
       ):
           """Create an oscillating joint.

           :param joint0: Center point of oscillation.
           :param amplitude: Maximum displacement from center.
           :param frequency: Oscillation frequency.
           :param phase: Phase offset in radians.
           """
           super().__init__(x, y, joint0, None, name)
           self.amplitude = amplitude
           self.frequency = frequency
           self.phase = phase
           self._time = 0.0

       def get_constraints(self):
           return (self.amplitude, self.frequency, self.phase)

       def set_constraints(self, amplitude=None, frequency=None, phase=None):
           if amplitude is not None:
               self.amplitude = amplitude
           if frequency is not None:
               self.frequency = frequency
           if phase is not None:
               self.phase = phase

       def reload(self, dt=1):
           self._time += dt
           if self.joint0 is None:
               center_x, center_y = 0, 0
           else:
               center_x, center_y = self.joint0.coord()

           offset = self.amplitude * math.sin(
               self.frequency * self._time + self.phase
           )
           self.x = center_x + offset
           self.y = center_y

Best Practices
--------------

When creating custom joints:

1. **Use __slots__**: Define ``__slots__`` with your additional attributes to
   save memory and prevent accidental attribute creation.

2. **Handle None parents**: Check if parent joints are ``None`` in ``reload()``.

3. **Return tuples from get_constraints**: Always return a tuple, even if empty.

4. **Document constraints**: Clearly document what each constraint value means.

5. **Consider optimization**: If your joint will be used in optimization,
   ensure constraints are continuous values that can be interpolated.

6. **Validate inputs**: Consider raising ``NotCompletelyDefinedError`` if
   required parameters are missing.

Next Steps
----------

- :doc:`advanced_optimization` - Optimize linkages with custom joints
- See :py:mod:`pylinkage.joints` for built-in joint implementations


Advanced Optimization Techniques
=================================

This tutorial covers advanced optimization techniques for linkage mechanisms
using pylinkage's Particle Swarm Optimization (PSO) and grid search capabilities.

Overview of Optimization
------------------------

Linkage optimization finds the best geometric parameters (distances, angles)
to achieve a desired motion. Pylinkage provides:

- **Particle Swarm Optimization (PSO)**: Efficient global optimization using swarm intelligence
- **Trials and Errors (Grid Search)**: Exhaustive search over a parameter grid

Defining a Fitness Function
---------------------------

The fitness function evaluates how well a linkage configuration meets your goals.
Use the ``@kinematic_minimization`` or ``@kinematic_maximization`` decorators.

Basic Fitness Function
^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

   import pylinkage as pl


   @pl.kinematic_minimization
   def fitness(loci, **kwargs):
       """Evaluate linkage fitness.

       :param loci: Joint positions for each simulation step.
           Structure: tuple[tuple[tuple[float, float], ...], ...]
           - Outer tuple: simulation steps
           - Middle tuple: joints at each step
           - Inner tuple: (x, y) coordinates
       :param kwargs: Additional arguments (linkage, constraints, etc.)
       :return: Fitness score (lower is better for minimization)
       """
       # Get the locus (path) of the last joint
       output_locus = [step[-1] for step in loci]

       # Calculate your fitness metric
       score = calculate_score(output_locus)
       return score

The decorator handles:

- Setting up the linkage with candidate constraints
- Running the simulation
- Catching ``UnbuildableError`` and returning infinity

Working with Loci Data
^^^^^^^^^^^^^^^^^^^^^^

Understanding the loci structure is key to writing good fitness functions:

.. code-block:: python

   @pl.kinematic_minimization
   def analyze_loci(loci, **kwargs):
       """Example showing loci structure."""
       # loci[step][joint] = (x, y)

       # Get all positions of joint 0 (usually the crank)
       crank_path = [step[0] for step in loci]

       # Get all positions of the last joint (output)
       output_path = [step[-1] for step in loci]

       # Get positions at a specific step
       positions_at_step_5 = loci[5]  # All joint positions at step 5

       # Calculate bounding box of output path
       bbox = pl.bounding_box(output_path)
       # bbox = (min_y, max_x, max_y, min_x)

       return some_score

Example: Optimizing for Path Shape
----------------------------------

Let's optimize a four-bar linkage so its output traces a specific rectangular path:

.. code-block:: python

   import pylinkage as pl


   def create_linkage():
       """Create the base linkage to optimize."""
       crank = pl.Crank(
           x=0, y=1,
           joint0=(0, 0),
           angle=0.31,
           distance=1,
           name="Crank"
       )
       output = pl.Revolute(
           x=3, y=2,
           joint0=crank,
           joint1=(3, 0),
           distance0=3,
           distance1=1,
           name="Output"
       )
       return pl.Linkage(
           joints=(crank, output),
           order=(crank, output),
       )


   @pl.kinematic_minimization
   def rectangle_fitness(loci, **kwargs):
       """Minimize distance from a target rectangle."""
       output_path = [step[-1] for step in loci]
       bbox = pl.bounding_box(output_path)

       # Target rectangle: min_y=0, max_x=5, max_y=2, min_x=3
       target = (0, 5, 2, 3)

       # Sum of squared differences
       return sum((actual - target_val) ** 2
                  for actual, target_val in zip(bbox, target))


   # Run optimization
   linkage = create_linkage()

   # Generate search bounds around current constraints
   bounds = pl.generate_bounds(linkage.get_num_constraints())

   results = pl.particle_swarm_optimization(
       eval_func=rectangle_fitness,
       linkage=linkage,
       bounds=bounds,
   )

   # Best result
   best_score, best_constraints, best_coords = results[0]
   print(f"Best score: {best_score}")

   # Apply best constraints and visualize
   linkage.set_num_constraints(best_constraints)
   pl.show_linkage(linkage)

Particle Swarm Optimization Parameters
--------------------------------------

Fine-tune PSO behavior for better results:

.. code-block:: python

   results = pl.particle_swarm_optimization(
       eval_func=fitness_function,
       linkage=linkage,
       bounds=bounds,

       # Number of particles in the swarm
       n_particles=100,      # More particles = better exploration, slower

       # Number of iterations
       iters=200,            # More iterations = better convergence, slower

       # Starting position (optional)
       center=None,          # Use current linkage constraints as center

       # Number of dimensions (usually auto-detected)
       dimensions=None,

       # Order relation for optimization
       order_relation=min,   # min for minimization, max for maximization
   )

Generating Bounds
-----------------

The ``generate_bounds`` function creates search ranges around current values:

.. code-block:: python

   constraints = linkage.get_num_constraints()
   # Example: [0.31, 1.0, 3.0, 1.0]

   bounds = pl.generate_bounds(constraints)
   # Returns: (lower_bounds, upper_bounds)
   # Default: values * 0.5 to values * 2.0

   # Custom bounds
   bounds = pl.generate_bounds(
       constraints,
       min_ratio=0.8,    # Lower bound = value * 0.8
       max_ratio=1.2,    # Upper bound = value * 1.2
   )

   # Or define bounds manually for precise control
   bounds = (
       [0.0, 0.5, 2.0, 0.5],    # Lower bounds
       [6.28, 2.0, 5.0, 2.0],   # Upper bounds
   )

Grid Search Optimization
------------------------

For simpler problems or exhaustive search:

.. code-block:: python

   results = pl.trials_and_errors_optimization(
       eval_func=fitness_function,
       linkage=linkage,
       divisions=20,          # Points per dimension
       order_relation=min,    # min or max
   )

   # Note: Grid search is O(divisions^n) where n = number of constraints
   # Use sparingly for high-dimensional problems

Multi-Objective Optimization
----------------------------

Combine multiple objectives in your fitness function:

.. code-block:: python

   @pl.kinematic_minimization
   def multi_objective_fitness(loci, **kwargs):
       """Optimize for both path shape and mechanism size."""
       output_path = [step[-1] for step in loci]
       crank_path = [step[0] for step in loci]

       # Objective 1: Match target bounding box
       bbox = pl.bounding_box(output_path)
       target = (0, 5, 2, 3)
       shape_error = sum((a - t) ** 2 for a, t in zip(bbox, target))

       # Objective 2: Minimize total mechanism size
       all_points = [p for step in loci for p in step]
       mech_bbox = pl.bounding_box(all_points)
       mechanism_size = (mech_bbox[1] - mech_bbox[3]) * (mech_bbox[2] - mech_bbox[0])

       # Weighted combination
       return shape_error + 0.1 * mechanism_size

Constraint Preservation
-----------------------

Sometimes you want to optimize only certain constraints while keeping others fixed:

.. code-block:: python

   @pl.kinematic_minimization
   def constrained_fitness(loci, linkage=None, constraints=None, **kwargs):
       """Fitness function that enforces additional constraints."""
       # Penalize if crank arm (constraint 1) is too short
       if constraints[1] < 0.5:
           return float('inf')

       # Normal fitness calculation
       output_path = [step[-1] for step in loci]
       return calculate_path_score(output_path)

Optimizing Initial Positions
----------------------------

Sometimes the issue isn't the constraints but the initial joint positions:

.. code-block:: python

   # Save and restore initial positions
   init_coords = linkage.get_coords()

   # Optimize
   results = pl.particle_swarm_optimization(
       eval_func=fitness,
       linkage=linkage,
       bounds=bounds,
   )

   # Apply results
   linkage.set_num_constraints(results[0][1])
   linkage.set_coords(init_coords)  # Restore initial positions

Visualizing Optimization Progress
---------------------------------

Track optimization progress with the strider example pattern:

.. code-block:: python

   history = []


   def tracking_fitness(linkage, constraints, initial_positions):
       """Wrapper that records optimization history."""
       # Your actual fitness calculation
       score = my_fitness(linkage, constraints, initial_positions)
       history.append((score, list(constraints), initial_positions))
       return score


   # Run optimization with tracking
   results = pl.particle_swarm_optimization(
       lambda *args: tracking_fitness(*args),
       linkage,
       bounds=bounds,
       n_particles=50,
       iters=100,
   )

   # Analyze history
   scores = [h[0] for h in history]
   print(f"Best score: {min(scores)}")
   print(f"Score improvement: {scores[0]} -> {scores[-1]}")

Async Optimization
------------------

For long-running optimizations, use the async version with progress callbacks:

.. code-block:: python

   import asyncio


   async def optimize_with_progress():
       def on_progress(iteration, best_score):
           print(f"Iteration {iteration}: best = {best_score}")

       results = await pl.particle_swarm_optimization_async(
           eval_func=fitness,
           linkage=linkage,
           bounds=bounds,
           progress_callback=on_progress,
       )
       return results


   # Run async optimization
   results = asyncio.run(optimize_with_progress())

Troubleshooting
---------------

**Optimization converges to poor solutions:**

- Increase ``n_particles`` for better exploration
- Widen the search bounds
- Check if your fitness function correctly penalizes bad configurations

**Many configurations are unbuildable:**

- Your bounds may include geometrically impossible regions
- Narrow the bounds around known-good configurations
- The ``@kinematic_minimization`` decorator returns ``inf`` for unbuildable configs

**Optimization is too slow:**

- Reduce ``n_particles`` or ``iters``
- Use coarser simulation (fewer steps in ``linkage.step()``)
- Consider grid search for low-dimensional problems
